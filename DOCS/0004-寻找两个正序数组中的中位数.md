题目描述：  
（PS：执行用时、消耗内存情况，每次提交可能结果不同，去掉注释速度可能更快）  
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。
```
示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```
```
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
 
```
 
```
提示：

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106
```
## Python
1、合并两个列表，对列表排序，对长度除2得到中间位置数字，如果是整数返回两个列表中间位置值的平均值，否则直接返回列表中的值  
注意：时间复杂度为O(m+n)，不满足O(log (m+n))
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        new_list = [*nums1,*nums2]
        new_list.sort()
        mid_index = len(new_list) / 2
        if mid_index == int(mid_index):
            return (new_list[int(mid_index)] + new_list[int(mid_index)-1]) / 2
        else:
            return new_list[int(mid_index)]
```
![alt text](images/image-15.png)

## C++
1、参考上面py（1）用c++实现
```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> merged;
        merged.reserve(nums1.size() + nums2.size());
        merged.insert(merged.end(), nums1.begin(), nums1.end());
        merged.insert(merged.end(), nums2.begin(), nums2.end());
        sort(merged.begin(), merged.end());
        int n = merged.size();
        return (n % 2) ? double(merged[n/2]) 
                : (double(merged[n/2-1]) + double(merged[n/2])) / 2.0;
    }
};
```
![alt text](images/0004-寻找两个正序数组中的中位数/image.png)



备注：官方题解，还有两个进阶思路：
思路1：获取两个数组长度后，求和并获取中位数索引，然后从0开始遍历，直到中位数索引位置，设置一个指针遍历，这个指针会在两个数组间跳动，那个数组当前值小，就右移一位，这样的思路时间复杂度为O(log (m+n))
另一个思路，看官方题解。
